/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  class JSI_EXPORT NativeMapViewModuleCxxSpecJSI : public TurboModule {
protected:
  NativeMapViewModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value takeSnap(jsi::Runtime &rt, std::optional<int> viewRef, bool writeToDisk) = 0;
  virtual jsi::Value queryTerrainElevation(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array coordinates) = 0;
  virtual jsi::Value setSourceVisibility(jsi::Runtime &rt, std::optional<int> viewRef, bool visible, jsi::String sourceId, jsi::String sourceLayerId) = 0;
  virtual jsi::Value getCenter(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
  virtual jsi::Value getCoordinateFromView(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atPoint) = 0;
  virtual jsi::Value getPointInView(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atCoordinate) = 0;
  virtual jsi::Value getZoom(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
  virtual jsi::Value getVisibleBounds(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
  virtual jsi::Value queryRenderedFeaturesAtPoint(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atPoint, jsi::Array withFilter, jsi::Array withLayerIDs) = 0;
  virtual jsi::Value queryRenderedFeaturesInRect(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array withBBox, jsi::Array withFilter, jsi::Array withLayerIDs) = 0;
  virtual jsi::Value setHandledMapChangedEvents(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array events) = 0;
  virtual jsi::Value clearData(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
  virtual jsi::Value querySourceFeatures(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String sourceId, jsi::Array withFilter, jsi::Array withSourceLayerIDs) = 0;
  virtual jsi::Value setFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, jsi::Object state, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) = 0;
  virtual jsi::Value getFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) = 0;
  virtual jsi::Value removeFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, std::optional<jsi::String> stateKey, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) = 0;

};

template <typename T>
class JSI_EXPORT NativeMapViewModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXMapViewModule";

protected:
  NativeMapViewModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeMapViewModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeMapViewModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeMapViewModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value takeSnap(jsi::Runtime &rt, std::optional<int> viewRef, bool writeToDisk) override {
      static_assert(
          bridging::getParameterCount(&T::takeSnap) == 3,
          "Expected takeSnap(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::takeSnap, jsInvoker_, instance_, std::move(viewRef), std::move(writeToDisk));
    }
    jsi::Value queryTerrainElevation(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array coordinates) override {
      static_assert(
          bridging::getParameterCount(&T::queryTerrainElevation) == 3,
          "Expected queryTerrainElevation(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::queryTerrainElevation, jsInvoker_, instance_, std::move(viewRef), std::move(coordinates));
    }
    jsi::Value setSourceVisibility(jsi::Runtime &rt, std::optional<int> viewRef, bool visible, jsi::String sourceId, jsi::String sourceLayerId) override {
      static_assert(
          bridging::getParameterCount(&T::setSourceVisibility) == 5,
          "Expected setSourceVisibility(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setSourceVisibility, jsInvoker_, instance_, std::move(viewRef), std::move(visible), std::move(sourceId), std::move(sourceLayerId));
    }
    jsi::Value getCenter(jsi::Runtime &rt, std::optional<int> viewRef) override {
      static_assert(
          bridging::getParameterCount(&T::getCenter) == 2,
          "Expected getCenter(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCenter, jsInvoker_, instance_, std::move(viewRef));
    }
    jsi::Value getCoordinateFromView(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atPoint) override {
      static_assert(
          bridging::getParameterCount(&T::getCoordinateFromView) == 3,
          "Expected getCoordinateFromView(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getCoordinateFromView, jsInvoker_, instance_, std::move(viewRef), std::move(atPoint));
    }
    jsi::Value getPointInView(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atCoordinate) override {
      static_assert(
          bridging::getParameterCount(&T::getPointInView) == 3,
          "Expected getPointInView(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getPointInView, jsInvoker_, instance_, std::move(viewRef), std::move(atCoordinate));
    }
    jsi::Value getZoom(jsi::Runtime &rt, std::optional<int> viewRef) override {
      static_assert(
          bridging::getParameterCount(&T::getZoom) == 2,
          "Expected getZoom(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getZoom, jsInvoker_, instance_, std::move(viewRef));
    }
    jsi::Value getVisibleBounds(jsi::Runtime &rt, std::optional<int> viewRef) override {
      static_assert(
          bridging::getParameterCount(&T::getVisibleBounds) == 2,
          "Expected getVisibleBounds(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getVisibleBounds, jsInvoker_, instance_, std::move(viewRef));
    }
    jsi::Value queryRenderedFeaturesAtPoint(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array atPoint, jsi::Array withFilter, jsi::Array withLayerIDs) override {
      static_assert(
          bridging::getParameterCount(&T::queryRenderedFeaturesAtPoint) == 5,
          "Expected queryRenderedFeaturesAtPoint(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::queryRenderedFeaturesAtPoint, jsInvoker_, instance_, std::move(viewRef), std::move(atPoint), std::move(withFilter), std::move(withLayerIDs));
    }
    jsi::Value queryRenderedFeaturesInRect(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array withBBox, jsi::Array withFilter, jsi::Array withLayerIDs) override {
      static_assert(
          bridging::getParameterCount(&T::queryRenderedFeaturesInRect) == 5,
          "Expected queryRenderedFeaturesInRect(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::queryRenderedFeaturesInRect, jsInvoker_, instance_, std::move(viewRef), std::move(withBBox), std::move(withFilter), std::move(withLayerIDs));
    }
    jsi::Value setHandledMapChangedEvents(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Array events) override {
      static_assert(
          bridging::getParameterCount(&T::setHandledMapChangedEvents) == 3,
          "Expected setHandledMapChangedEvents(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setHandledMapChangedEvents, jsInvoker_, instance_, std::move(viewRef), std::move(events));
    }
    jsi::Value clearData(jsi::Runtime &rt, std::optional<int> viewRef) override {
      static_assert(
          bridging::getParameterCount(&T::clearData) == 2,
          "Expected clearData(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::clearData, jsInvoker_, instance_, std::move(viewRef));
    }
    jsi::Value querySourceFeatures(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String sourceId, jsi::Array withFilter, jsi::Array withSourceLayerIDs) override {
      static_assert(
          bridging::getParameterCount(&T::querySourceFeatures) == 5,
          "Expected querySourceFeatures(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::querySourceFeatures, jsInvoker_, instance_, std::move(viewRef), std::move(sourceId), std::move(withFilter), std::move(withSourceLayerIDs));
    }
    jsi::Value setFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, jsi::Object state, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) override {
      static_assert(
          bridging::getParameterCount(&T::setFeatureState) == 6,
          "Expected setFeatureState(...) to have 6 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setFeatureState, jsInvoker_, instance_, std::move(viewRef), std::move(featureId), std::move(state), std::move(sourceId), std::move(sourceLayerId));
    }
    jsi::Value getFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) override {
      static_assert(
          bridging::getParameterCount(&T::getFeatureState) == 5,
          "Expected getFeatureState(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getFeatureState, jsInvoker_, instance_, std::move(viewRef), std::move(featureId), std::move(sourceId), std::move(sourceLayerId));
    }
    jsi::Value removeFeatureState(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureId, std::optional<jsi::String> stateKey, jsi::String sourceId, std::optional<jsi::String> sourceLayerId) override {
      static_assert(
          bridging::getParameterCount(&T::removeFeatureState) == 6,
          "Expected removeFeatureState(...) to have 6 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::removeFeatureState, jsInvoker_, instance_, std::move(viewRef), std::move(featureId), std::move(stateKey), std::move(sourceId), std::move(sourceLayerId));
    }

  private:
    friend class NativeMapViewModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRNMBXCameraModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXCameraModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value updateCameraStop(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Object stop) = 0;
  virtual jsi::Value moveBy(jsi::Runtime &rt, std::optional<int> viewRef, double x, double y, double animationMode, double animationDuration) = 0;
  virtual jsi::Value scaleBy(jsi::Runtime &rt, std::optional<int> viewRef, double x, double y, double animationMode, double animationDuration, double scaleFactor) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXCameraModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXCameraModule";

protected:
  NativeRNMBXCameraModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXCameraModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNMBXCameraModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXCameraModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value updateCameraStop(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Object stop) override {
      static_assert(
          bridging::getParameterCount(&T::updateCameraStop) == 3,
          "Expected updateCameraStop(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::updateCameraStop, jsInvoker_, instance_, std::move(viewRef), std::move(stop));
    }
    jsi::Value moveBy(jsi::Runtime &rt, std::optional<int> viewRef, double x, double y, double animationMode, double animationDuration) override {
      static_assert(
          bridging::getParameterCount(&T::moveBy) == 6,
          "Expected moveBy(...) to have 6 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::moveBy, jsInvoker_, instance_, std::move(viewRef), std::move(x), std::move(y), std::move(animationMode), std::move(animationDuration));
    }
    jsi::Value scaleBy(jsi::Runtime &rt, std::optional<int> viewRef, double x, double y, double animationMode, double animationDuration, double scaleFactor) override {
      static_assert(
          bridging::getParameterCount(&T::scaleBy) == 7,
          "Expected scaleBy(...) to have 7 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::scaleBy, jsInvoker_, instance_, std::move(viewRef), std::move(x), std::move(y), std::move(animationMode), std::move(animationDuration), std::move(scaleFactor));
    }

  private:
    friend class NativeRNMBXCameraModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value generate(jsi::Runtime &rt, int tag, jsi::Array coordinates, double startOffset, double endOffset) = 0;
  virtual jsi::Value setLineString(jsi::Runtime &rt, int tag, jsi::Array coordinates, double startOffset, double endOffset) = 0;
  virtual jsi::Value setStartOffset(jsi::Runtime &rt, int tag, double offset, double duration) = 0;
  virtual jsi::Value setEndOffset(jsi::Runtime &rt, int tag, double offset, double duration) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXChangeLineOffsetsShapeAnimatorModule";

protected:
  NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value generate(jsi::Runtime &rt, int tag, jsi::Array coordinates, double startOffset, double endOffset) override {
      static_assert(
          bridging::getParameterCount(&T::generate) == 5,
          "Expected generate(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::generate, jsInvoker_, instance_, std::move(tag), std::move(coordinates), std::move(startOffset), std::move(endOffset));
    }
    jsi::Value setLineString(jsi::Runtime &rt, int tag, jsi::Array coordinates, double startOffset, double endOffset) override {
      static_assert(
          bridging::getParameterCount(&T::setLineString) == 5,
          "Expected setLineString(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setLineString, jsInvoker_, instance_, std::move(tag), std::move(coordinates), std::move(startOffset), std::move(endOffset));
    }
    jsi::Value setStartOffset(jsi::Runtime &rt, int tag, double offset, double duration) override {
      static_assert(
          bridging::getParameterCount(&T::setStartOffset) == 4,
          "Expected setStartOffset(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setStartOffset, jsInvoker_, instance_, std::move(tag), std::move(offset), std::move(duration));
    }
    jsi::Value setEndOffset(jsi::Runtime &rt, int tag, double offset, double duration) override {
      static_assert(
          bridging::getParameterCount(&T::setEndOffset) == 4,
          "Expected setEndOffset(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setEndOffset, jsInvoker_, instance_, std::move(tag), std::move(offset), std::move(duration));
    }

  private:
    friend class NativeRNMBXChangeLineOffsetsShapeAnimatorModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRNMBXImageModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXImageModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value refresh(jsi::Runtime &rt, std::optional<int> viewRef) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXImageModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXImageModule";

protected:
  NativeRNMBXImageModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXImageModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNMBXImageModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXImageModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value refresh(jsi::Runtime &rt, std::optional<int> viewRef) override {
      static_assert(
          bridging::getParameterCount(&T::refresh) == 2,
          "Expected refresh(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::refresh, jsInvoker_, instance_, std::move(viewRef));
    }

  private:
    friend class NativeRNMBXImageModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeRNMBXLocationModuleLocationEvent

template <typename P0, typename P1>
struct NativeRNMBXLocationModuleLocationEvent {
  P0 type;
  P1 payload;
  bool operator==(const NativeRNMBXLocationModuleLocationEvent &other) const {
    return type == other.type && payload == other.payload;
  }
};

template <typename T>
struct NativeRNMBXLocationModuleLocationEventBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.type)>(rt, value.getProperty(rt, "type"), jsInvoker),
      bridging::fromJs<decltype(types.payload)>(rt, value.getProperty(rt, "payload"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String typeToJs(jsi::Runtime &rt, decltype(types.type) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::Object payloadToJs(jsi::Runtime &rt, decltype(types.payload) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "type", bridging::toJs(rt, value.type, jsInvoker));
    result.setProperty(rt, "payload", bridging::toJs(rt, value.payload, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeRNMBXLocationModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXLocationModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void start(jsi::Runtime &rt, double minDisplacement) = 0;
  virtual void stop(jsi::Runtime &rt) = 0;
  virtual void setRequestsAlwaysUse(jsi::Runtime &rt, bool requestsAlwaysUse) = 0;
  virtual void setMinDisplacement(jsi::Runtime &rt, double minDisplacement) = 0;
  virtual jsi::Value getLastKnownLocation(jsi::Runtime &rt) = 0;
  virtual void simulateHeading(jsi::Runtime &rt, double changesPerSecond, double increment) = 0;
  virtual void setLocationEventThrottle(jsi::Runtime &rt, double throttle) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXLocationModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXLocationModule";

protected:
  NativeRNMBXLocationModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXLocationModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

  template <typename OnLocationUpdateType> void emitOnLocationUpdate(OnLocationUpdateType value) {
    static_assert(bridging::supportsFromJs<OnLocationUpdateType, jsi::Object>, "value cannnot be converted to jsi::Object");
    static_cast<AsyncEventEmitter<jsi::Value>&>(*delegate_.eventEmitterMap_["onLocationUpdate"]).emit([jsInvoker = jsInvoker_, eventValue = value](jsi::Runtime& rt) -> jsi::Value {
      return bridging::toJs(rt, eventValue, jsInvoker);
    });
  }

private:
  class Delegate : public NativeRNMBXLocationModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXLocationModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {
      eventEmitterMap_["onLocationUpdate"] = std::make_shared<AsyncEventEmitter<jsi::Value>>();
    }

    void start(jsi::Runtime &rt, double minDisplacement) override {
      static_assert(
          bridging::getParameterCount(&T::start) == 2,
          "Expected start(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::start, jsInvoker_, instance_, std::move(minDisplacement));
    }
    void stop(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stop) == 1,
          "Expected stop(...) to have 1 parameters");

      return bridging::callFromJs<void>(
          rt, &T::stop, jsInvoker_, instance_);
    }
    void setRequestsAlwaysUse(jsi::Runtime &rt, bool requestsAlwaysUse) override {
      static_assert(
          bridging::getParameterCount(&T::setRequestsAlwaysUse) == 2,
          "Expected setRequestsAlwaysUse(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setRequestsAlwaysUse, jsInvoker_, instance_, std::move(requestsAlwaysUse));
    }
    void setMinDisplacement(jsi::Runtime &rt, double minDisplacement) override {
      static_assert(
          bridging::getParameterCount(&T::setMinDisplacement) == 2,
          "Expected setMinDisplacement(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setMinDisplacement, jsInvoker_, instance_, std::move(minDisplacement));
    }
    jsi::Value getLastKnownLocation(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getLastKnownLocation) == 1,
          "Expected getLastKnownLocation(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getLastKnownLocation, jsInvoker_, instance_);
    }
    void simulateHeading(jsi::Runtime &rt, double changesPerSecond, double increment) override {
      static_assert(
          bridging::getParameterCount(&T::simulateHeading) == 3,
          "Expected simulateHeading(...) to have 3 parameters");

      return bridging::callFromJs<void>(
          rt, &T::simulateHeading, jsInvoker_, instance_, std::move(changesPerSecond), std::move(increment));
    }
    void setLocationEventThrottle(jsi::Runtime &rt, double throttle) override {
      static_assert(
          bridging::getParameterCount(&T::setLocationEventThrottle) == 2,
          "Expected setLocationEventThrottle(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setLocationEventThrottle, jsInvoker_, instance_, std::move(throttle));
    }

  private:
    friend class NativeRNMBXLocationModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value generate(jsi::Runtime &rt, int tag, jsi::Array coordinate) = 0;
  virtual jsi::Value moveTo(jsi::Runtime &rt, int tag, jsi::Array coordinate, double duration) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXMovePointShapeAnimatorModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXMovePointShapeAnimatorModule";

protected:
  NativeRNMBXMovePointShapeAnimatorModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXMovePointShapeAnimatorModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXMovePointShapeAnimatorModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value generate(jsi::Runtime &rt, int tag, jsi::Array coordinate) override {
      static_assert(
          bridging::getParameterCount(&T::generate) == 3,
          "Expected generate(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::generate, jsInvoker_, instance_, std::move(tag), std::move(coordinate));
    }
    jsi::Value moveTo(jsi::Runtime &rt, int tag, jsi::Array coordinate, double duration) override {
      static_assert(
          bridging::getParameterCount(&T::moveTo) == 4,
          "Expected moveTo(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::moveTo, jsInvoker_, instance_, std::move(tag), std::move(coordinate), std::move(duration));
    }

  private:
    friend class NativeRNMBXMovePointShapeAnimatorModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRNMBXPointAnnotationModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXPointAnnotationModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value refresh(jsi::Runtime &rt, std::optional<int> viewRef) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXPointAnnotationModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXPointAnnotationModule";

protected:
  NativeRNMBXPointAnnotationModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXPointAnnotationModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNMBXPointAnnotationModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXPointAnnotationModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value refresh(jsi::Runtime &rt, std::optional<int> viewRef) override {
      static_assert(
          bridging::getParameterCount(&T::refresh) == 2,
          "Expected refresh(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::refresh, jsInvoker_, instance_, std::move(viewRef));
    }

  private:
    friend class NativeRNMBXPointAnnotationModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRNMBXShapeSourceModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXShapeSourceModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getClusterExpansionZoom(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON) = 0;
  virtual jsi::Value getClusterLeaves(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON, int number, int offset) = 0;
  virtual jsi::Value getClusterChildren(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXShapeSourceModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXShapeSourceModule";

protected:
  NativeRNMBXShapeSourceModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXShapeSourceModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNMBXShapeSourceModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXShapeSourceModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value getClusterExpansionZoom(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON) override {
      static_assert(
          bridging::getParameterCount(&T::getClusterExpansionZoom) == 3,
          "Expected getClusterExpansionZoom(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getClusterExpansionZoom, jsInvoker_, instance_, std::move(viewRef), std::move(featureJSON));
    }
    jsi::Value getClusterLeaves(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON, int number, int offset) override {
      static_assert(
          bridging::getParameterCount(&T::getClusterLeaves) == 5,
          "Expected getClusterLeaves(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getClusterLeaves, jsInvoker_, instance_, std::move(viewRef), std::move(featureJSON), std::move(number), std::move(offset));
    }
    jsi::Value getClusterChildren(jsi::Runtime &rt, std::optional<int> viewRef, jsi::String featureJSON) override {
      static_assert(
          bridging::getParameterCount(&T::getClusterChildren) == 3,
          "Expected getClusterChildren(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getClusterChildren, jsInvoker_, instance_, std::move(viewRef), std::move(featureJSON));
    }

  private:
    friend class NativeRNMBXShapeSourceModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRNMBXTileStoreModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXTileStoreModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value shared(jsi::Runtime &rt, std::optional<jsi::String> path) = 0;
  virtual jsi::Value setOption(jsi::Runtime &rt, int tag, jsi::String key, jsi::String domain, jsi::Object value) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXTileStoreModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXTileStoreModule";

protected:
  NativeRNMBXTileStoreModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXTileStoreModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNMBXTileStoreModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXTileStoreModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value shared(jsi::Runtime &rt, std::optional<jsi::String> path) override {
      static_assert(
          bridging::getParameterCount(&T::shared) == 2,
          "Expected shared(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::shared, jsInvoker_, instance_, std::move(path));
    }
    jsi::Value setOption(jsi::Runtime &rt, int tag, jsi::String key, jsi::String domain, jsi::Object value) override {
      static_assert(
          bridging::getParameterCount(&T::setOption) == 5,
          "Expected setOption(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setOption, jsInvoker_, instance_, std::move(tag), std::move(key), std::move(domain), std::move(value));
    }

  private:
    friend class NativeRNMBXTileStoreModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  class JSI_EXPORT NativeRNMBXViewportModuleCxxSpecJSI : public TurboModule {
protected:
  NativeRNMBXViewportModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value getState(jsi::Runtime &rt, std::optional<int> viewRef) = 0;
  virtual jsi::Value transitionTo(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Object state, jsi::Object transition) = 0;
  virtual jsi::Value idle(jsi::Runtime &rt, std::optional<int> viewRef) = 0;

};

template <typename T>
class JSI_EXPORT NativeRNMBXViewportModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "RNMBXViewportModule";

protected:
  NativeRNMBXViewportModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeRNMBXViewportModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeRNMBXViewportModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeRNMBXViewportModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value getState(jsi::Runtime &rt, std::optional<int> viewRef) override {
      static_assert(
          bridging::getParameterCount(&T::getState) == 2,
          "Expected getState(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getState, jsInvoker_, instance_, std::move(viewRef));
    }
    jsi::Value transitionTo(jsi::Runtime &rt, std::optional<int> viewRef, jsi::Object state, jsi::Object transition) override {
      static_assert(
          bridging::getParameterCount(&T::transitionTo) == 4,
          "Expected transitionTo(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::transitionTo, jsInvoker_, instance_, std::move(viewRef), std::move(state), std::move(transition));
    }
    jsi::Value idle(jsi::Runtime &rt, std::optional<int> viewRef) override {
      static_assert(
          bridging::getParameterCount(&T::idle) == 2,
          "Expected idle(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::idle, jsInvoker_, instance_, std::move(viewRef));
    }

  private:
    friend class NativeRNMBXViewportModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
